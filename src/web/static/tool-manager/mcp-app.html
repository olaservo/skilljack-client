<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="color-scheme" content="light dark">
  <title>Tool Manager</title>
  <style>
    :root {
      --bg: #1a1a2e;
      --bg-secondary: #16213e;
      --text: #e8e8e8;
      --text-secondary: #a0a0a0;
      --accent: #6366f1;
      --accent-hover: #818cf8;
      --border: #2a2a4a;
      --success: #22c55e;
      --warning: #eab308;
    }

    @media (prefers-color-scheme: light) {
      :root {
        --bg: #ffffff;
        --bg-secondary: #f5f5f5;
        --text: #1a1a1a;
        --text-secondary: #666666;
        --border: #e0e0e0;
      }
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      padding: 12px;
      min-height: 100vh;
      overflow-y: auto;
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--border);
    }

    h1 {
      font-size: 18px;
      font-weight: 600;
    }

    .stats {
      font-size: 12px;
      color: var(--text-secondary);
    }

    /* Section styles */
    .section {
      margin-bottom: 16px;
    }

    .section-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 0;
      cursor: pointer;
      user-select: none;
    }

    .section-header h2 {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-secondary);
    }

    .section-toggle {
      font-size: 10px;
      color: var(--text-secondary);
      transition: transform 0.2s;
    }

    .section.collapsed .section-toggle {
      transform: rotate(-90deg);
    }

    .section.collapsed .section-content {
      display: none;
    }

    .section-content {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    /* Server item */
    .server-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 6px 8px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 6px;
      transition: border-color 0.2s;
    }

    .server-item:hover {
      border-color: var(--accent);
    }

    .server-item.disabled {
      opacity: 0.5;
    }

    .server-info {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .server-name {
      font-weight: 500;
      font-size: 14px;
    }

    .server-badge {
      font-size: 11px;
      padding: 2px 6px;
      background: var(--accent);
      color: white;
      border-radius: 4px;
    }

    .server-tool-count {
      font-size: 11px;
      color: var(--text-secondary);
    }

    .filters {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
    }

    .filter-input {
      flex: 1;
      padding: 6px 8px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg-secondary);
      color: var(--text);
      font-size: 13px;
    }

    .filter-input:focus {
      outline: none;
      border-color: var(--accent);
    }

    .filter-select {
      padding: 6px 8px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg-secondary);
      color: var(--text);
      font-size: 13px;
      cursor: pointer;
    }

    .ui-filter {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--bg-secondary);
      color: var(--text);
      font-size: 13px;
      cursor: pointer;
      white-space: nowrap;
    }

    .ui-filter input {
      cursor: pointer;
    }

    .tool-list {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .tool-item {
      display: flex;
      align-items: flex-start;
      gap: 8px;
      padding: 8px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 6px;
      transition: border-color 0.2s;
    }

    .tool-item:hover {
      border-color: var(--accent);
    }

    .tool-item.disabled {
      opacity: 0.5;
    }

    .tool-info {
      flex: 1;
      min-width: 0;
    }

    .tool-header {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 2px;
    }

    .tool-name {
      font-weight: 500;
      font-size: 13px;
    }

    .tool-server {
      font-size: 11px;
      padding: 2px 6px;
      background: var(--accent);
      color: white;
      border-radius: 4px;
      white-space: nowrap;
    }

    .tool-ui-badge {
      font-size: 10px;
      padding: 2px 5px;
      background: var(--success);
      color: white;
      border-radius: 4px;
    }

    /* Warning level badges */
    .tool-warning-badge {
      font-size: 10px;
      padding: 2px 5px;
      color: white;
      border-radius: 4px;
      cursor: help;
    }

    .tool-warning-safe {
      background: var(--success);
    }

    .tool-warning-caution {
      background: var(--warning);
      color: #1a1a1a;
    }

    .tool-warning-danger {
      background: #ef4444;
    }

    .tool-description {
      font-size: 11px;
      color: var(--text-secondary);
      line-height: 1.3;
      overflow: hidden;
      text-overflow: ellipsis;
      display: -webkit-box;
      -webkit-line-clamp: 1;
      -webkit-box-orient: vertical;
    }

    .toggle {
      position: relative;
      width: 36px;
      height: 20px;
      flex-shrink: 0;
    }

    .toggle input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: var(--border);
      transition: 0.3s;
      border-radius: 24px;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 14px;
      width: 14px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: 0.3s;
      border-radius: 50%;
    }

    .toggle input:checked + .toggle-slider {
      background-color: var(--success);
    }

    .toggle input:checked + .toggle-slider:before {
      transform: translateX(16px);
    }

    .toggle input:disabled + .toggle-slider {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .loading {
      text-align: center;
      padding: 40px;
      color: var(--text-secondary);
    }

    .error {
      text-align: center;
      padding: 40px;
      color: #ef4444;
    }

    .empty {
      text-align: center;
      padding: 40px;
      color: var(--text-secondary);
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Tool Manager</h1>
    <div class="stats" id="stats">Loading...</div>
  </div>

  <!-- Servers Section -->
  <div class="section" id="servers-section">
    <div class="section-header" onclick="toggleSection('servers-section')">
      <span class="section-toggle">▼</span>
      <h2>Servers</h2>
    </div>
    <div class="section-content" id="server-list">
      <div class="loading">Loading servers...</div>
    </div>
  </div>

  <!-- Tools Section -->
  <div class="section" id="tools-section">
    <div class="section-header" onclick="toggleSection('tools-section')">
      <span class="section-toggle">▼</span>
      <h2>Tools</h2>
    </div>
    <div class="section-content">
      <div class="filters">
        <input type="text" class="filter-input" id="search" placeholder="Filter tools...">
        <select class="filter-select" id="server-filter">
          <option value="">All Servers</option>
        </select>
        <label class="ui-filter">
          <input type="checkbox" id="ui-only">
          <span>UI only</span>
        </label>
      </div>
      <div class="tool-list" id="tool-list">
        <div class="loading">Loading tools...</div>
      </div>
    </div>
  </div>

  <script>
    // State
    let tools = [];
    let servers = [];
    let serverNames = new Set();
    let useJsonRpc = false; // Will be set to true if running in iframe (Electron mode)
    let rpcRequestId = 1;
    const pendingRequests = new Map();

    // Get host origin (injected by host, or fallback to referrer/location)
    const hostOrigin = window.__HOST_ORIGIN__
      || (document.referrer ? new URL(document.referrer).origin : window.location.origin);

    // Detect if we're in an iframe (Electron mode uses sandboxed iframes)
    const isInIframe = window.parent !== window;

    // Elements
    const serverList = document.getElementById('server-list');
    const toolList = document.getElementById('tool-list');
    const stats = document.getElementById('stats');
    const searchInput = document.getElementById('search');
    const serverFilter = document.getElementById('server-filter');

    // ============================================
    // JSON-RPC Communication (for Electron mode)
    // ============================================

    // Send JSON-RPC request to host
    function sendRpcRequest(method, params = {}) {
      return new Promise((resolve, reject) => {
        const id = rpcRequestId++;
        pendingRequests.set(id, { resolve, reject });

        window.parent.postMessage({
          jsonrpc: '2.0',
          id,
          method,
          params
        }, '*');

        // Timeout after 10 seconds
        setTimeout(() => {
          if (pendingRequests.has(id)) {
            pendingRequests.delete(id);
            reject(new Error('Request timeout'));
          }
        }, 10000);
      });
    }

    // Handle JSON-RPC responses from host
    window.addEventListener('message', (event) => {
      const data = event.data;
      if (!data || typeof data !== 'object' || data.jsonrpc !== '2.0') return;

      // Handle response (has id and result/error)
      if (data.id && pendingRequests.has(data.id)) {
        const { resolve, reject } = pendingRequests.get(data.id);
        pendingRequests.delete(data.id);

        if (data.error) {
          reject(new Error(data.error.message || 'RPC error'));
        } else {
          resolve(data.result);
        }
      }
    });

    // Toggle section collapse
    function toggleSection(sectionId) {
      const section = document.getElementById(sectionId);

    // ============================================
    // Tool Warning Level (from annotations)
    // ============================================

    /**
     * Get warning level for a tool based on its annotations.
     * - 'safe': Read-only tools
     * - 'caution': Non-destructive or idempotent tools
     * - 'danger': Destructive, non-idempotent tools (or no annotations)
     */
    function getWarningLevel(tool) {
      const annotations = tool.annotations;

      // No annotations = assume dangerous
      if (!annotations) return 'danger';

      // Read-only tools are safe
      if (annotations.readOnlyHint) return 'safe';

      // Check destructive and idempotent hints (with defaults per MCP spec)
      const isDestructive = annotations.destructiveHint !== false; // default true
      const isIdempotent = annotations.idempotentHint === true; // default false

      // Destructive, non-idempotent tools are dangerous
      if (isDestructive && !isIdempotent) return 'danger';

      // Non-destructive or idempotent tools are caution
      return 'caution';
    }

    /**
     * Get human-readable reason for warning level.
     */
    function getWarningReason(tool) {
      const annotations = tool.annotations;

      if (!annotations) {
        return 'No annotations - assuming dangerous';
      }

      if (annotations.readOnlyHint) {
        return 'Read-only - does not modify environment';
      }

      const isDestructive = annotations.destructiveHint !== false;
      const isIdempotent = annotations.idempotentHint === true;

      if (isDestructive && !isIdempotent) {
        return 'Destructive and non-idempotent';
      }

      if (!isDestructive) {
        return 'Non-destructive';
      }

      if (isIdempotent) {
        return 'Idempotent - safe to retry';
      }

      return 'May modify environment';
    }

    /**
     * Get warning badge HTML for a tool.
     */
    function getWarningBadge(tool) {
      const level = getWarningLevel(tool);
      const reason = getWarningReason(tool);
      const labels = { safe: 'Safe', caution: 'Caution', danger: 'Danger' };
      return `<span class="tool-warning-badge tool-warning-${level}" title="${escapeHtml(reason)}">${labels[level]}</span>`;
    }
      section.classList.toggle('collapsed');
    }

    // ============================================
    // Data Fetching (HTTP or JSON-RPC)
    // ============================================

    // Fetch servers
    async function fetchServers() {
      try {
        let data;
        if (useJsonRpc) {
          data = await sendRpcRequest('tool-manager/getServers');
        } else {
          const res = await fetch(`${hostOrigin}/api/tool-manager/servers`);
          if (!res.ok) throw new Error('Failed to fetch servers');
          data = await res.json();
        }
        servers = data.servers || [];
        renderServers();
      } catch (err) {
        // If HTTP fails and we're in iframe, switch to JSON-RPC mode
        if (!useJsonRpc && isInIframe) {
          console.log('[ToolManager] HTTP failed, switching to JSON-RPC mode');
          useJsonRpc = true;
          return fetchServers();
        }
        serverList.innerHTML = `<div class="error">Failed to load servers: ${err.message}</div>`;
      }
    }

    // Fetch tools
    async function fetchTools() {
      try {
        let data;
        if (useJsonRpc) {
          data = await sendRpcRequest('tool-manager/getTools');
        } else {
          const res = await fetch(`${hostOrigin}/api/tool-manager/tools`);
          if (!res.ok) throw new Error('Failed to fetch tools');
          data = await res.json();
        }
        tools = data.tools || [];
        serverNames = new Set(tools.map(t => t.serverName));
        updateServerFilter();
        renderTools();
      } catch (err) {
        // If HTTP fails and we're in iframe, switch to JSON-RPC mode
        if (!useJsonRpc && isInIframe) {
          console.log('[ToolManager] HTTP failed, switching to JSON-RPC mode');
          useJsonRpc = true;
          return fetchTools();
        }
        toolList.innerHTML = `<div class="error">Failed to load tools: ${err.message}</div>`;
      }
    }

    // Update server filter dropdown
    function updateServerFilter() {
      const current = serverFilter.value;
      serverFilter.innerHTML = '<option value="">All Servers</option>';
      for (const server of [...serverNames].sort()) {
        const opt = document.createElement('option');
        opt.value = server;
        opt.textContent = server;
        serverFilter.appendChild(opt);
      }
      serverFilter.value = current;
    }

    // Toggle server enabled state
    async function toggleServer(name, enabled) {
      try {
        if (useJsonRpc) {
          await sendRpcRequest('tool-manager/setServerEnabled', { name, enabled });
        } else {
          const res = await fetch(`${hostOrigin}/api/tool-manager/servers/${encodeURIComponent(name)}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ enabled }),
          });
          if (!res.ok) throw new Error('Failed to update server');
        }

        // Refresh both servers and tools (tools' enabled state depends on server)
        await Promise.all([fetchServers(), fetchTools()]);
      } catch (err) {
        console.error('Toggle server failed:', err);
        // Revert UI on error
        renderServers();
      }
    }

    // Toggle tool enabled state
    async function toggleTool(name, enabled) {
      try {
        if (useJsonRpc) {
          await sendRpcRequest('tool-manager/setToolEnabled', { name, enabled });
        } else {
          const res = await fetch(`${hostOrigin}/api/tool-manager/tools/${encodeURIComponent(name)}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ enabled }),
          });
          if (!res.ok) throw new Error('Failed to update tool');
        }

        // Update local state
        const tool = tools.find(t => t.name === name);
        if (tool) tool.enabled = enabled;
        renderTools();
      } catch (err) {
        console.error('Toggle tool failed:', err);
        // Revert UI on error
        renderTools();
      }
    }

    // Render servers list
    function renderServers() {
      if (servers.length === 0) {
        serverList.innerHTML = '<div class="empty">No servers found</div>';
        return;
      }

      serverList.innerHTML = servers.map(server => `
        <div class="server-item ${server.enabled ? '' : 'disabled'}">
          <div class="server-info">
            <span class="server-name">${escapeHtml(server.name)}</span>
            <span class="server-tool-count">${server.toolCount} tool${server.toolCount !== 1 ? 's' : ''}</span>
          </div>
          <label class="toggle">
            <input type="checkbox"
                   ${server.enabled ? 'checked' : ''}
                   onchange="toggleServer('${escapeJs(server.name)}', this.checked)">
            <span class="toggle-slider"></span>
          </label>
        </div>
      `).join('');
    }

    // Render tool list
    function renderTools() {
      const search = searchInput.value.toLowerCase();
      const server = serverFilter.value;
      const uiOnly = document.getElementById('ui-only').checked;

      const filtered = tools.filter(tool => {
        if (uiOnly && !tool.hasUi) return false;
        if (server && tool.serverName !== server) return false;
        if (search) {
          const searchable = `${tool.name} ${tool.displayName} ${tool.description || ''}`.toLowerCase();
          if (!searchable.includes(search)) return false;
        }
        return true;
      });

      // Update stats
      const enabled = tools.filter(t => t.enabled).length;
      const serversEnabled = servers.filter(s => s.enabled).length;
      stats.textContent = `${serversEnabled}/${servers.length} servers, ${enabled}/${tools.length} tools`;

      if (filtered.length === 0) {
        toolList.innerHTML = '<div class="empty">No tools found</div>';
        return;
      }

      toolList.innerHTML = filtered.map(tool => `
        <div class="tool-item ${tool.enabled ? '' : 'disabled'}">
          <div class="tool-info">
            <div class="tool-header">
              <span class="tool-name">${escapeHtml(tool.displayName)}</span>
              <span class="tool-server">${escapeHtml(tool.serverName)}</span>
              ${tool.hasUi ? '<span class="tool-ui-badge">UI</span>' : ''}
              ${getWarningBadge(tool)}
            </div>
            <div class="tool-description">${escapeHtml(tool.description || 'No description')}</div>
          </div>
          <label class="toggle">
            <input type="checkbox"
                   ${tool.enabled ? 'checked' : ''}
                   data-name="${escapeHtml(tool.name)}"
                   onchange="toggleTool('${escapeJs(tool.name)}', this.checked)">
            <span class="toggle-slider"></span>
          </label>
        </div>
      `).join('');
    }

    // Escape HTML
    function escapeHtml(str) {
      if (!str) return '';
      return str.replace(/[&<>"']/g, c => ({
        '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
      })[c]);
    }

    // Escape for JS string
    function escapeJs(str) {
      if (!str) return '';
      return str.replace(/[\\'"]/g, '\\$&');
    }

    // Event listeners
    searchInput.addEventListener('input', renderTools);
    serverFilter.addEventListener('change', renderTools);
    document.getElementById('ui-only').addEventListener('change', renderTools);

    // Initial load
    // If in iframe, start with JSON-RPC mode to avoid HTTP timeout
    if (isInIframe) {
      console.log('[ToolManager] Running in iframe, using JSON-RPC mode');
      useJsonRpc = true;
    }
    Promise.all([fetchServers(), fetchTools()]);
  </script>
</body>
</html>
